---
title: "文档型数据库和图数据库分析"
date: 2021-04-09T15:15:11+08:00
draft: false
tags: []
categories: []
author: ""
---

> 对比常用文档型数据库，如ElasticSearch、MongoDB，图数据库，如JanusGraph、Neo4J等。

# ElasticSearch

## 数据模型：文档型数据库

![doc-db](../../static/img/20210409/doc-db.png)

## 概念

* document(文档)

document由一个或者多个Field（域）组成，每个Field由一个名称和一个或者多个值（有多个值的叫做multi-valued）组成。在ES中，每个document都可能会有不同的Field集合，也就是说document没有固定的模式和统一的结构。document之间保持着相似性即可。从客户端的角度来看，document就是一个JSON对象。

Mapping（映射）是定义document以及其包含的字段的存储和索引方式的过程。每个索引都有一种映射类型，用于确定文档的索引方式。 在6.0.0中已弃用映射类型（即只有一个固定的类型名，不能自定义）。7.x之后每个索引只有一个type，名字为_doc。Mapping可以显式的指定，也可以动态映射。

1. 显式映射（对比数据库中定义的表结构）
   可以在创建索引时创建字段映射，也可以使用PUT映射API将字段添加到现有索引。

    ```shell
       curl -X PUT "localhost:9200/my_index" -H 'Content-Type: application/json' -d'
       {
        "mappings": {　　
            "_doc": { 　　　　//映射类型为 _doc
            "properties": {  　　//定义字段或者properties
                "title":    { "type": "text"  },  //定义字段title的字段类型为text
                "name":     { "type": "text"  }, 
                "age":      { "type": "integer" },  
                "created":  {
                "type":   "date", 
                "format": "strict_date_optional_time||epoch_millis"
                }
             }
            }
          }
       }
       '
    ```

 2. 动态映射（根据字段的值自动推断字段的类型）
    在使用之前不定义字段和映射类型，ES只需要索引文档就能自动添加新的字段名称。同一个字段第一次出现的时候就确定了字段类型，后续此字段必须符合这个字段类型。

ES中的mapping一旦创建之后，就无法修改，只能追加。如果需要修改，就需要删除掉整个文档，进行重建。

* index（索引）

ES会把数据存放到一个或者多个index（索引）中，索引存放和读取基本单元是document（文档）。在ES中，被视为单独的一个index，在Lucene中可能不止一个，这是因为在分布式系统中，ES会用到分片（Shards）和备份（replicas）机制将一个index存储多份。

* type(文档类型)

每个文档在ES中都必须设定它的类型，文档类型使得同一个索引中存储结构不同的文档时，只需要根据文档类型就可以找到对应的参数映射（Mapping）信息，方便文档的存取。

ES6时，官方就提到了ES7会删除type，并且在ES6时已经规定每个index只能有一个type，在ES7中使用默认的_doc作为type，官方说在8.x版本将彻底移除type。API请求方式也发生了变化，对索引的文档进行操作的时候，默认使用的Type是_doc。获得某个索引的某个ID的文档：GET {index}/_doc/{id}。

* Node（节点）

一个ES服务器的实例就是一个节点。考虑到容错和数据过载，一般会配置多节点的ES集群。

* Cluster（集群）

集群是多个ES节点的集合。多节点构成的集群可以应对单节点无法处理的搜索需求和数据存储需求。也能够应对由于部分机器（节点）运行中断或者升级导致无法提供服务的问题。

* Shard（分片索引）

集群能够存储超过单台机器容量的信息，为了实现这种需求，ES把数据分发到多个存储Lucene索引的物理机上。这些Luncene索引称为分片索引，这个分发的过程称为索引分片（Sharding）。在ES集群中，Sharding是自动完成的，而且所有的Shard是作为一个整体呈现给用户的。尽管Sharding过程是自动的，但是应用中需要事前配置好参数，因为集群中分片的数量需要在索引创建之前配置好，且服务启动后是无法修改的。

协调节点(coordinating node)通过文档id的hash值（murmur3散列函数）和主分片数量（Primary shard）取模，确定文档应被索引到哪个分片。
shard = hash(document_id) % (num_of_primary_shards)

* Replica（索引副本）

通过Sharding（索引分片）机制，可以向ES集群中导入超过单机容量的数据，客户端操作任意一个节点即可以实现对集群数据的读写操作。当集群负载增长，用户搜索请求阻塞在某个节点时，通过索引副本（Replica）就可以解决这个问题。索引副本可以动态的添加或者删除，用户可以再需要的时候动态调整其数量。

![es-replica](../../static/img/20210409/es-replica.png)

primary shard的默认数量是5，replica默认是1，默认有10个shard，5个primary shard，5个replica shard。

* Gateway

Gateway是ES用来存储索引的文件系统，支持多种类型。包括本地文件系统(默认)，HDFS，S3等，Gateway代表ES的持久化存储方式，包含索引信息，ClusterState(集群信息)，mapping，索引碎片信息，以及transaction log等。

## 架构

* 整体架构图

![es-arch](../../static/img/20210409/es-arch.png)

* 集群节点、分片、副本

![es-node-replica](../../static/img/20210409/es-node-replica.png)

* 数据逻辑结构图

![es-index-doc-term](../../static/img/20210409/es-index-doc-term.png)

## ES的打分机制

[打分机制](https://doc.yonyoucloud.com/doc/mastering-elasticsearch/chapter-2/21_README.html)

## 优点（性能、稳定性、易用性、扩展性、文档完备性）

* 开箱即用。安装好ElasticSearch后，所有参数的默认值都自动进行了比较合理的设置，基本不需要额外的调整。包括内置的发现机制(比如Field类型的自动匹配)和自动化参数配置。

* 天生集群。ElasticSearch默认工作在集群模式下。节点都将视为集群的一部分，而且在启动的过程中自动连接到集群中。

* 自动容错。ElasticSearch通过P2P网络进行通信，这种工作方式消除了单点故障。节点自动连接到集群中的其它机器，自动进行数据交换及以节点之间相互监控。

* 扩展性强。无论是处理能力和数据容量上都可以通过一种简单的方式实现扩展，即增添新的节点。

* 近实时搜索和版本控制。由于ElasticSearch天生支持分布式，所以延迟和不同节点上数据的短暂性不一致无可避免。ElasticSearch通过版本控制(versioning)的机制尽量减少问题的出现。

## 缺点

* 不支持事务
* 资源消耗高
* 写入默认有1s延迟

## ES读写过程
### ES写数据过程

* ES写数据的大概流程 

1.客户端选择一个node发送请求过去，这个node就是coordinating node（协调节点）
2.coordinating node对document进行路由，将请求转发给对应的node（primary shard）
3.node上的primary shard处理请求，然后将数据同步到replica node
4.coordinating node，如果发现primary node和replica node都搞定之后，就返回响应结果给客户端

* ES写数据的底层原理

1.先写入buffer，在buffer里的时候数据是搜索不到的；同时将数据写入translog日志文件

2.如果buffer快满了，或者每隔一秒钟，就会将buffer数据refresh到一个新的segment file中并清空buffer，但是此时数据不是直接进入segment file的磁盘文件的，而是先进入os cache的。当数据进入os cache后，就代表该数据可以被检索到了。因此说es是准实时的，这个过程就是refresh。

3.只要数据进入os cache，此时就可以让这个segment file的数据对外提供搜索了

4.重复1~3步骤，新的数据不断进入buffer和translog，不断将buffer数据写入一个又一个新的segment file中去，每次refresh完buffer清空，translog保留。随着这个过程推进，translog会变得越来越大。当translog达到一定长度的时候，就会触发commit操作。

commit操作（也叫flush操作，默认每隔30分钟执行一次）：执行refresh操作 -> 写commit point -> 将os cache数据fsync强刷到磁盘上去 -> 清空translog日志文件

commit操作保证了在机器宕机时，buffer和os cache中未同步到segment file中的数据还可以在重启之后恢复到内存buffer和os cache中去，

5.translog其实也是先写入os cache的，默认每隔5秒刷一次到磁盘中去，所以默认情况下，可能有5秒的数据会仅仅停留在buffer或者translog文件的os cache中，如果此时机器挂了，会丢失5秒钟的数据。但是这样性能比较好，最多丢5秒的数据。也可以将translog设置成每次写操作必须是直接fsync到磁盘，但是性能会差很多。

6.如果是删除操作，commit的时候会生成一个.del文件，里面将某个doc标识为deleted状态，那么搜索的时候根据.del文件就知道这个doc被删除了

7.如果是更新操作，就是将原来的doc标识为deleted状态，然后新写入一条数据

8.buffer每次refresh一次，就会产生一个segment file，所以默认情况下是1秒钟一个segment file，segment file会越来越多，此时会定期执行merge,当segment多到一定的程度时，自动触发merge操作

9.每次merge的时候，会将多个segment file合并成一个，同时这里会将标识为deleted的doc给物理删除掉，然后将新的segment file写入磁盘，这里会写一个commit point，标识所有新的segment file，然后打开segment file供搜索使用，同时删除旧的segment file。

**es里的写流程中主要的4个底层核心概念，refresh、flush、translog、merge**

### ES读数据过程

* ES读取数据的大概流程

在写入ES时，ES会给每个document分配一个全局唯一的id（如果未指定id的话），读取的时候也是对这个doc id进行hash，路由到对应的primary shard上去的。过程如下：

1.客户端发送请求到任意一个node，该node称为coordinating node

2.coordinating node对document进行路由，建请求转发到对应的node，此时会使用round-robin随机轮询算法，在primary shard以及其replica中随机选择一个，进行读请求的负载均衡

3.将查询到的对应的的document返回给coordinating node

4.coordinating node 返回 document给客户端

* ES搜索数据的过程

1.客户端发送请求到coordinating node

2.coordinating node 将搜索请求转发到所有的shard对应的primary shard或者replica shard上

3.query phase： 每个shard将自己的搜索结果（实际是doc id）返回给coordinating shard， 由coordinating shard进行数据的合并、排序、分页等操作，并产出最终结果

4.fetch phase： coordinating node根据doc id去各个节点拉取document数据，并最终返回给客户端。


# MongoDB

## 数据模型：文档型数据库

![doc-db](../../static/img/20210409/doc-db.png)

## 架构

## 优点（性能、稳定性、易用性、扩展性、文档完备性）

## 缺点

# HBase

## 数据模型：列式数据存储

![column-db](../../static/img/20210409/column-db.png)

## 架构

## 优点（性能、稳定性、易用性、扩展性、文档完备性）

## 缺点


# JanusGraph

## 数据模型：图数据库

![graph-db](../../static/img/20210409/graph-db.png)

## 优点（性能、稳定性、易用性、扩展性、文档完备性）

## 缺点


# Neo4J

## 数据模型：图数据库

![graph-db](../../static/img/20210409/graph-db.png)

## 优点（性能、稳定性、易用性、扩展性、文档完备性）

## 缺点


# 参考

* [ES中文文档](https://doc.yonyoucloud.com/doc/mastering-elasticsearch/chapter-1/index.html)
* [MongoDB和ElasticSearch的对比](https://leriou.github.io/2019-01-09-mongodb-compareto-elasticsearch/)
* [ES基础与读写原理](https://www.jianshu.com/p/cdace70842aa)